<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Poorly Written Notes]]></title><description><![CDATA[Poorly Written Notes]]></description><link>https://ipcamit.github.io/</link><image><url>https://ipcamit.github.io/favicon.png</url><title>Poorly Written Notes</title><link>https://ipcamit.github.io/</link></image><generator>Ghost 4.35</generator><lastBuildDate>Mon, 22 Aug 2022 15:51:23 GMT</lastBuildDate><atom:link href="https://ipcamit.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Setting up Clojure and SCIMUtils as an absolute beginner]]></title><description><![CDATA[<h2 id="clojure-setup">Clojure setup</h2><p>So recently I was starting up on Clojure for SCIMUtils library, which is an excellent port of original scimutils written in MIT-Scheme. Clojure version provides overall better documentation and tooling experience than the Scheme version.</p><p>However Clojure is bit more <em>eccentric</em> for my taste and I was having</p>]]></description><link>https://ipcamit.github.io/setting-up-clojure-and-scimutils-as-an-absolute-beginner/</link><guid isPermaLink="false">6303a080a666a4169b288ed7</guid><dc:creator><![CDATA[Amit Gupta]]></dc:creator><pubDate>Mon, 22 Aug 2022 15:34:29 GMT</pubDate><content:encoded><![CDATA[<h2 id="clojure-setup">Clojure setup</h2><p>So recently I was starting up on Clojure for SCIMUtils library, which is an excellent port of original scimutils written in MIT-Scheme. Clojure version provides overall better documentation and tooling experience than the Scheme version.</p><p>However Clojure is bit more <em>eccentric</em> for my taste and I was having hard time getting started. Shout out to user <a href="https://github.com/pmonks"><strong>pmonks</strong></a> from the Discord Clojure chatroom <code>Discljord</code> for being patient and helpful enough to guide me though its first steps. Following is the conversation with him. Most of it is replicated verbatim, except few changes in structure, and editing where required. Plus it is really really hard to get help on MIT-Scheme</p><h3 id="bit-of-background">Bit of background</h3><p>So the first thing that&#x2019;s a bit odd is that you would normally use either <code>lein</code> or <code>clj</code>, but rarely both together. They&#x2019;re basically competing build tools / environments.<br>Sort of - it&#x2019;s supposed to be a more modern take on a Clojure build tool, and is published by Cognitect (the creators of Clojure), so has more &#x201C;cachet&#x201D;. &#xA0;Whether it&#x2019;s &#x201C;better&#x201D; than Leiningen or not at this point is a matter of debate. <code>clj</code> just wraps Clojure in <code>rlwrap</code> - they are otherwise identical. So yes, for interactive REPLs, you&#x2019;d usually want <code>clj</code>.</p><h3 id="structure-of-clojure-project">Structure of Clojure project</h3><p>Anyway, one of the first things to understand about package management / libraries in Clojure (which is actually a limitation of the JVM) is that hot-loading libraries is a bit fraught. There are hacky ways to partially do it, but I would not recommend them unless you&#x2019;re already fairly familiar &#xA0;with how the JVM loads code. So what we have to do instead is declare our dependencies up front, then start a REPL (and if the dependencies change, generally speaking the best bet is to quit and restart the REPL).</p><p>For clj &amp; clojure, dependencies are expressed in a file that (by default) is called <code>deps.edn</code>. To declare a dependency on SICMUtils, the contents of that file would be</p><pre><code>{:deps {sicmutils/sicmutils {:mvn/version &quot;0.22.0&quot;}}}
</code></pre><p>This is same as given on Clojars page clj column. Clojars &#x201C;knows&#x201D; about the clj/clojure tools, so they provide this as a handy copypasta.</p><p>Also the clj tool assumes source code is housed under a sub directory called <code>src</code>. So the directory structure should be:</p><pre><code>new_project/
|
+- deps.edn
|
+- src/
    |
    +- core.clj
</code></pre><p>Though if your namespace is new-project.core, that should actually be:</p><pre><code>new_project/
|
+- deps.edn
|
+- src/
    |
    +- new_project/
        |
        +- core.clj

</code></pre><p>The <code>core.clj</code> contains simple hello world program.</p><pre><code class="language-clojure">(ns new_project.core)

(defn hello
  []
  (println &quot;Hello World&quot;))
</code></pre><p>Once you have that file in an otherwise empty directory, if you start a clj / clojure REPL in that directory, you should see it download the library (first time only) then start a REPL where that library is available.</p><p>All downloaded packages are by default kept in a &#x201C;per user&#x201D; cache in ~/.m2.<br>That means that if you use the same dependency in multiple separate projects you&#x2019;re not downloading the same libraries over and over again. This is standard practice across many/most JVM-hosted languages.<br>Clojure simply leverages the underlying JVM ecosystem.</p><h3 id="running-the-program">Running the Program</h3><p>To load code from a file you would normally require that file&#x2019;s namespace, then use the vars it declares from your own namespace (user in the case of the REPL).<br>Now to load code from a file using require, there is a naming convention for that file&#x2019;s name that you have to follow (since Clojure has a particular mapping from ns symbol to file-on-disk).</p><p>As an example, if your file declares a namespace called my.cool.namespace, the file would need to be called ./my/cool/namespace.clj (yes that&#x2019;s a directory structure).</p><p>Oh and one JVM oddity to watch out for - if your namespace name includes hyphens anywhere (&#x201C;-&#x201C;), those would be replaced with an underscore (&#x201C;_&#x201D;) in the filename. This is another JVM oddity that Clojure has to workaround.</p><p>Once you have your core.clj named and located properly, to load and use it in the REPL, you&#x2019;d just require the namespace e.g. in above case it will be</p><pre><code class="language-clojure">(require &apos;[new_project.core as cr]).
</code></pre><p>vars in that namespace are then available via the <code>cr</code> prefix. e.g. <code>(cr/hello)</code></p><p>Oh and one nice thing that Clojure can do for Clojure code, is that if your file changes you can reload it without exiting the REPL. To do that:</p><pre><code class="language-clojure">(require &apos;[new_project.core as cr] :reload-all)
</code></pre><p>So from inside your poject folder you should have final structure as:</p><pre><code>$ tree .
.
&#x251C;&#x2500;&#x2500; deps.edn
&#x2514;&#x2500;&#x2500; src
    &#x2514;&#x2500;&#x2500; new_project
        &#x2514;&#x2500;&#x2500; core.clj

2 directories, 2 files
</code></pre><p>And the <code>clj</code> commandline looks like:</p><pre><code>$ clj                               
Clojure 1.11.1
user=&gt; (require &apos;[new_project.core :as cr])
nil
user=&gt; (cr/hello)
Hello World
nil
user=&gt; 
</code></pre><p>Thats it! Now you can head to <a href="https://cljdoc.org/d/sicmutils/sicmutils/0.22.0/doc/basics/how-to-use-sicmutils">SCIMutils docs</a> and start doing what the page tells you to.</p>]]></content:encoded></item><item><title><![CDATA[Automatic Differentiation]]></title><description><![CDATA[<p>This is a small presentation I gave in lab meeting, introducing principles of automatic differentiation. Among various AD frameworks, Autograd, Autodiff, and Enzyme were benchmarked over Stillinger-Weber potential of Si atoms. Stillinger-Weber was chosen as most benchmarks and frameworks focus on traditional linear algebra kind problems, where as I am</p>]]></description><link>https://ipcamit.github.io/automatic-differentiation/</link><guid isPermaLink="false">62219df56e106b87beb6b776</guid><dc:creator><![CDATA[Amit Gupta]]></dc:creator><pubDate>Fri, 04 Mar 2022 05:53:21 GMT</pubDate><content:encoded><![CDATA[<p>This is a small presentation I gave in lab meeting, introducing principles of automatic differentiation. Among various AD frameworks, Autograd, Autodiff, and Enzyme were benchmarked over Stillinger-Weber potential of Si atoms. Stillinger-Weber was chosen as most benchmarks and frameworks focus on traditional linear algebra kind problems, where as I am more interested on ML applications on more scientific problems. All the code would be uploaded in github soon. Presentation can be downloaded <a href="https://1drv.ms/b/s!Ave1F6LmCN-jg7l-XVDYJgHCQiQC2A">here</a>. Sources for figures and content are given in the end.</p><hr><!--kg-card-begin: html--><iframe src="https://onedrive.live.com/embed?cid=A3DF08E6A217B5F7&amp;resid=A3DF08E6A217B5F7%2156574&amp;authkey=AKK7axh_MMKMdDg&amp;em=2" width="800" height="500" frameborder="0" scrolling="no"></iframe><!--kg-card-end: html-->]]></content:encoded></item></channel></rss>